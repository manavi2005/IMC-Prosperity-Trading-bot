# -*- coding: utf-8 -*-
"""Blackascholes.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ldr47d_zrQpX-dOmnwBanQQETPn6Pu6q
"""

from datamodel import OrderDepth, TradingState, Order
from typing import List, Tuple, Dict
import jsonpickle
import math

# Optional: try to import matplotlib for plotting
try:
    import matplotlib.pyplot as plt
except ImportError:
    plt = None

# Optional: try to import numpy for vectorized operations
try:
    import numpy as np
except ImportError:
    np = None


def compute_mid_price(order_depth: OrderDepth, fallback: float) -> float:
    """
    Compute mid price from the order depth. Falls back if the order book is incomplete.
    """
    if not order_depth.sell_orders or not order_depth.buy_orders:
        return fallback
    best_ask = min(order_depth.sell_orders.keys())
    best_bid = max(order_depth.buy_orders.keys())
    return (best_bid + best_ask) / 2


def volume_weighted_price(orders: Dict[float, int]) -> float:
    """
    Compute a volume–weighted price from a dictionary of orders.
    """
    total_volume = sum(abs(vol) for vol in orders.values())
    if total_volume == 0:
        return 0
    return sum(price * abs(vol) for price, vol in orders.items()) / total_volume


def volume_weighted_price_np(orders: Dict[float, int]) -> float:
    """
    Compute a volume–weighted price using NumPy.
    """
    if np is not None:
        prices = np.array(list(orders.keys()))
        volumes = np.abs(np.array(list(orders.values())))
        if volumes.sum() == 0:
            return 0
        return float(np.dot(prices, volumes) / volumes.sum())
    else:
        return volume_weighted_price(orders)


def black_scholes_call_price(S: float, K: float, T: float, r: float, sigma: float) -> float:
    """
    Compute the price of a European call using the Black–Scholes formula.

    S     = spot price of underlying
    K     = strike price
    T     = time to maturity (expressed in years; you can treat T as days/365)
    r     = risk-free interest rate
    sigma = implied volatility
    """
    # Avoid division by zero issues
    T = max(T, 1e-9)
    sigma = max(sigma, 1e-9)

    d1 = (math.log(S / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * math.sqrt(T))
    d2 = d1 - sigma * math.sqrt(T)

    def cdf(x):
        return 0.5 * (1 + math.erf(x / math.sqrt(2)))

    call_val = S * cdf(d1) - K * math.exp(-r * T) * cdf(d2)
    return call_val


#                     TRADER CLASS

class Trader:
    def __init__(self,
                 execution_slippage: float = 0.2,     # Lower slippage to encourage trading
                 transaction_cost: float = 0.2,       # Lower transaction cost penalty
                 risk_coefficient: float = 0.05,      # Lower risk penalty
                 max_trade_volume: int = 10,          # Increase max trade volume per order
                 reversion_coefficient: float = 0.5
                ):
        self.execution_slippage = execution_slippage
        self.transaction_cost = transaction_cost
        self.risk_coefficient = risk_coefficient
        self.max_trade_volume = max_trade_volume
        self.reversion_coefficient = reversion_coefficient

        # Historical data trackers for plotting and metrics.
        self.kelp_prices = []        # Stores fair values for KELP.
        self.kelp_vwap = []          # Stores VWAP and volume info for KELP.
        self.squidink_prices = []    # Stores fair values for SQUID_INK.
        self.flipper_second_bids = []  # For the manual Flippers challenge.

        # Volcanic Rock Voucher configuration
        self.volcanic_voucher_config = {
            "VOLCANIC_ROCK_VOUCHER_9500":  {"strike": 9500,  "limit": 300, "T": 7, "r": 0.0, "sigma": 0.2},
            "VOLCANIC_ROCK_VOUCHER_9750":  {"strike": 9750,  "limit": 200, "T": 7, "r": 0.0, "sigma": 0.2},
            "VOLCANIC_ROCK_VOUCHER_10000": {"strike": 10000, "limit": 200, "T": 7, "r": 0.0, "sigma": 0.2},
            "VOLCANIC_ROCK_VOUCHER_10250": {"strike": 10250, "limit": 200, "T": 7, "r": 0.0, "sigma": 0.2},
            "VOLCANIC_ROCK_VOUCHER_10500": {"strike": 10500, "limit": 200, "T": 7, "r": 0.0, "sigma": 0.2},
        }

    # 1) RESIN STRATEGY (Fixed fair value)
    def resin_orders(self, order_depth: OrderDepth, fair_value: int, width: int,
                     position: int, position_limit: int) -> List[Order]:
        orders: List[Order] = []
        buy_order_volume = 0
        sell_order_volume = 0

        # Maintain a fixed fair value for Resin.
        fair_value = 10000

        # Process buy orders.
        if order_depth.sell_orders:
            best_ask = min(order_depth.sell_orders.keys())
            best_ask_amount = -order_depth.sell_orders[best_ask]
            if best_ask < fair_value:
                quantity = min(best_ask_amount, position_limit - position)
                if quantity > 0:
                    orders.append(Order("RAINFOREST_RESIN", best_ask, quantity))
                    buy_order_volume += quantity

        # Process sell orders.
        if order_depth.buy_orders:
            best_bid = max(order_depth.buy_orders.keys())
            best_bid_amount = order_depth.buy_orders[best_bid]
            if best_bid > fair_value:
                quantity = min(best_bid_amount, position_limit + position)
                if quantity > 0:
                    orders.append(Order("RAINFOREST_RESIN", best_bid, -quantity))
                    sell_order_volume += quantity

        buy_order_volume, sell_order_volume = self.clear_position_order(
            orders, order_depth, position, position_limit, "RAINFOREST_RESIN",
            buy_order_volume, sell_order_volume, fair_value, width=1
        )

        # Fill remaining capacity with passive orders.
        buy_quantity = position_limit - (position + buy_order_volume)
        if buy_quantity > 0:
            orders.append(Order("RAINFOREST_RESIN", fair_value - 1, buy_quantity))
        sell_quantity = position_limit + (position - sell_order_volume)
        if sell_quantity > 0:
            orders.append(Order("RAINFOREST_RESIN", fair_value + 1, -sell_quantity))

        return orders

    # 2) KELP STRATEGY
    def kelp_fair_value(self, order_depth: OrderDepth, method="volume_weighted") -> float:
        """
        Compute fair value using either volume–weighted or best–price averaging.
        """
        if not order_depth.sell_orders or not order_depth.buy_orders:
            return 2000  # fallback value

        best_ask = min(order_depth.sell_orders.keys())
        best_bid = max(order_depth.buy_orders.keys())
        if method == "volume_weighted":
            total_sell_volume = sum(abs(vol) for vol in order_depth.sell_orders.values())
            total_buy_volume = sum(abs(vol) for vol in order_depth.buy_orders.values())
            if total_sell_volume == 0 or total_buy_volume == 0:
                return 2000
            weighted_sell = volume_weighted_price(order_depth.sell_orders)
            weighted_buy  = volume_weighted_price(order_depth.buy_orders)
            return (weighted_sell + weighted_buy) / 2
        return (best_ask + best_bid) / 2

    def kelp_orders(self, order_depth: OrderDepth, timespan: int, width: float,
                    take_width: float, position: int, position_limit: int) -> List[Order]:
        orders: List[Order] = []
        buy_order_volume = 0
        sell_order_volume = 0

        if not order_depth.sell_orders or not order_depth.buy_orders:
            return orders

        best_ask = min(order_depth.sell_orders.keys())
        best_bid = max(order_depth.buy_orders.keys())
        fair_value = self.kelp_fair_value(order_depth, method="volume_weighted")

        # Calculate volume and VWAP between best bid and best ask.
        volume = -order_depth.sell_orders[best_ask] + order_depth.buy_orders[best_bid]
        vwap = (best_bid * (-order_depth.sell_orders[best_ask]) +
                best_ask * order_depth.buy_orders[best_bid]) / volume

        # Track history for analysis/plotting.
        self.kelp_vwap.append({"vol": volume, "vwap": vwap})
        self.kelp_prices.append(fair_value)
        if len(self.kelp_vwap) > timespan:
            self.kelp_vwap.pop(0)
        if len(self.kelp_prices) > timespan:
            self.kelp_prices.pop(0)

        # Aggressive orders if prices deviate by take_width.
        if best_ask <= fair_value - take_width:
            ask_amount = -order_depth.sell_orders[best_ask]
            if ask_amount <= 20:
                quantity = min(ask_amount, position_limit - position)
                if quantity > 0:
                    orders.append(Order("KELP", best_ask, quantity))
                    buy_order_volume += quantity

        if best_bid >= fair_value + take_width:
            bid_amount = order_depth.buy_orders[best_bid]
            if bid_amount <= 20:
                quantity = min(bid_amount, position_limit + position)
                if quantity > 0:
                    orders.append(Order("KELP", best_bid, -quantity))
                    sell_order_volume += quantity

        buy_order_volume, sell_order_volume = self.clear_position_order(
            orders, order_depth, position, position_limit, "KELP",
            buy_order_volume, sell_order_volume, fair_value, width=2
        )

        # Passive order pricing using nearby orders.
        aaf = [price for price in order_depth.sell_orders.keys() if price > fair_value + 1]
        bbf = [price for price in order_depth.buy_orders.keys() if price < fair_value - 1]
        passive_sell_price = min(aaf) if aaf else fair_value + 2
        passive_buy_price = max(bbf) if bbf else fair_value - 2

        buy_quantity = position_limit - (position + buy_order_volume)
        if buy_quantity > 0:
            orders.append(Order("KELP", passive_buy_price + 1, buy_quantity))
        sell_quantity = position_limit + (position - sell_order_volume)
        if sell_quantity > 0:
            orders.append(Order("KELP", passive_sell_price - 1, -sell_quantity))
        return orders

    # 3) SQUID INK STRATEGY WITH MEAN REVERSION
    def squidink_fair_value(self, order_depth: OrderDepth, method="volume_weighted") -> float:
        """
        Similar to kelp_fair_value, but for SQUID_INK.
        """
        if not order_depth.sell_orders or not order_depth.buy_orders:
            return 2000
        best_ask = min(order_depth.sell_orders.keys())
        best_bid = max(order_depth.buy_orders.keys())
        if method == "volume_weighted":
            total_sell_volume = sum(abs(vol) for vol in order_depth.sell_orders.values())
            total_buy_volume = sum(abs(vol) for vol in order_depth.buy_orders.values())
            if total_sell_volume == 0 or total_buy_volume == 0:
                return 2000
            weighted_sell = volume_weighted_price(order_depth.sell_orders)
            weighted_buy  = volume_weighted_price(order_depth.buy_orders)
            return (weighted_sell + weighted_buy) / 2
        return (best_ask + best_bid) / 2

    def compute_swing_metric(self, window: int = 10) -> Tuple[float, float]:
        """
        Compute the moving average and standard deviation for recent SQUID_INK fair values.
        """
        recent = self.squidink_prices[-window:] if len(self.squidink_prices) >= window else self.squidink_prices
        if not recent:
            return 0, 0
        avg = sum(recent) / len(recent)
        variance = sum((x - avg) ** 2 for x in recent) / len(recent)
        std = math.sqrt(variance)
        return avg, std

    def mid_price(self, order_depth: OrderDepth, fallback: float) -> float:
        return compute_mid_price(order_depth, fallback)

    def optimize_conversion_arbitrage(self, prices: dict, position_limits: dict) -> Tuple[dict, float]:
        """
        A simple linear program approach for conversion arbitrage between baskets and components.
        """
        items = ["CROISSANT", "JAM", "DJEMBE", "PICNIC_BASKET1", "PICNIC_BASKET2"]
        fv_c = prices["CROISSANT"]
        fv_j = prices["JAM"]
        fv_d = prices["DJEMBE"]
        synthetic_b1 = 6 * fv_c + 3 * fv_j + 1 * fv_d
        synthetic_b2 = 4 * fv_c + 2 * fv_j

        adv = [
            prices["CROISSANT"] - fv_c,
            prices["JAM"] - fv_j,
            prices["DJEMBE"] - fv_d,
            prices["PICNIC_BASKET1"] - synthetic_b1,
            prices["PICNIC_BASKET2"] - synthetic_b2,
        ]

        decision = {}
        total_profit = 0
        for i, item in enumerate(items):
            limit = position_limits[item]
            if adv[i] > 0:
                decision[item] = limit
                total_profit += adv[i] * limit
            elif adv[i] < 0:
                decision[item] = -limit
                total_profit += adv[i] * (-limit)
            else:
                decision[item] = 0

        return decision, total_profit

    def decompose_lp_conversion_orders(self, state: TradingState, prices: dict, lp_decision: dict) -> List[Order]:
        """
        Convert the LP decision into executable orders by comparing LP target with current positions.
        """
        conversion_orders = []
        for product, target_net in lp_decision.items():
            current_position = state.position.get(product, 0)
            order_volume = target_net - current_position
            if abs(order_volume) < 1:
                continue
            if product in state.order_depths:
                od = state.order_depths[product]
                if order_volume > 0 and od.sell_orders:
                    price = min(od.sell_orders.keys())
                elif order_volume < 0 and od.buy_orders:
                    price = max(od.buy_orders.keys())
                else:
                    price = prices.get(product, 1000)
            else:
                price = prices.get(product, 1000)
            conversion_orders.append(Order(product, price, int(order_volume)))
        return conversion_orders

    def squidink_utility_orders(self, order_depth: OrderDepth, position: int, position_limit: int,
                                fair_value_base: float = 2000, candidate_range: int = 2) -> List[Order]:
        """
        Use a utility optimization approach with a mean reversion bonus.
        """
        orders: List[Order] = []
        fair_value = self.squidink_fair_value(order_depth, method="volume_weighted")
        if fair_value == 0:
            fair_value = fair_value_base

        self.squidink_prices.append(fair_value)
        avg, std = self.compute_swing_metric(window=10)
        z = (fair_value - avg) / std if std > 0 else 0

        candidate_prices = [int(fair_value + offset) for offset in range(-candidate_range, candidate_range + 1)]
        best_buy_price = None
        best_buy_utility = float("-inf")
        best_sell_price = None
        best_sell_utility = float("-inf")

        best_ask = min(order_depth.sell_orders.keys()) if order_depth.sell_orders else None
        best_bid = max(order_depth.buy_orders.keys()) if order_depth.buy_orders else None

        for price in candidate_prices:
            # Evaluate potential buy
            if best_ask is not None and price < fair_value:
                distance = best_ask - price
                exec_prob = max(0, 1 - (distance / candidate_range))
                profit = fair_value - price - self.execution_slippage - self.transaction_cost
                penalty = self.risk_coefficient * abs(position + 1)
                base_utility = (profit - penalty) * exec_prob
                bonus = self.reversion_coefficient * (-z) if z < 0 else 0
                utility = base_utility + bonus
                if utility > best_buy_utility:
                    best_buy_utility = utility
                    best_buy_price = price

            # Evaluate potential sell
            if best_bid is not None and price > fair_value:
                distance = price - best_bid
                exec_prob = max(0, 1 - (distance / candidate_range))
                profit = price - fair_value - self.execution_slippage - self.transaction_cost
                penalty = self.risk_coefficient * abs(position - 1)
                base_utility = (profit - penalty) * exec_prob
                bonus = self.reversion_coefficient * z if z > 0 else 0
                utility = base_utility + bonus
                if utility > best_sell_utility:
                    best_sell_utility = utility
                    best_sell_price = price

        buy_volume = min(self.max_trade_volume, position_limit - position)
        sell_volume = min(self.max_trade_volume, position_limit + position)
        if best_buy_price is not None and buy_volume > 0:
            orders.append(Order("SQUID_INK", best_buy_price, buy_volume))
        if best_sell_price is not None and sell_volume > 0:
            orders.append(Order("SQUID_INK", best_sell_price, -sell_volume))
        return orders

    # 4) VOLCANIC ROCK VOUCHERS STRATEGY
    def volcanic_voucher_orders(self, product: str, order_depth: OrderDepth,
                                position: int) -> List[Order]:
        orders: List[Order] = []
        config = self.volcanic_voucher_config[product]
        strike = config["strike"]
        position_limit = config["limit"]
        T = config["T"]
        r = config["r"]
        sigma = config["sigma"]

        # Use a naive assumption for the underlying price (or infer from a VOLCANIC_ROCK order book if available)
        S = 10000.0
        T_years = T / 365.0
        theoretical_price = black_scholes_call_price(S, strike, T_years, r, sigma)

        if order_depth.sell_orders:
            best_ask = min(order_depth.sell_orders.keys())
            best_ask_qty = -order_depth.sell_orders[best_ask]
            if best_ask < theoretical_price:
                buy_qty = min(best_ask_qty, position_limit - position)
                if buy_qty > 0:
                    orders.append(Order(product, best_ask, buy_qty))
        if order_depth.buy_orders:
            best_bid = max(order_depth.buy_orders.keys())
            best_bid_qty = order_depth.buy_orders[best_bid]
            if best_bid > theoretical_price:
                sell_qty = min(best_bid_qty, position_limit + position)
                if sell_qty > 0:
                    orders.append(Order(product, best_bid, -sell_qty))
        return orders

    # 5) BREAD/JAM/DJEMBE/BASKET STRATEGIES
    def croissant_fair_value(self, order_depth: OrderDepth) -> float:
        return compute_mid_price(order_depth, 4300)

    def jam_fair_value(self, order_depth: OrderDepth) -> float:
        return compute_mid_price(order_depth, 6600)

    def djembe_fair_value(self, order_depth: OrderDepth) -> float:
        return compute_mid_price(order_depth, 13400)

    def croissant_orders(self, order_depth: OrderDepth, position: int, position_limit: int) -> List[Order]:
        orders: List[Order] = []
        fair_value = self.croissant_fair_value(order_depth)
        if order_depth.sell_orders:
            best_ask = min(order_depth.sell_orders.keys())
            available = -order_depth.sell_orders[best_ask]
            if best_ask < fair_value:
                quantity = min(available, position_limit - position, self.max_trade_volume)
                if quantity > 0:
                    orders.append(Order("CROISSANT", best_ask, quantity))
        if order_depth.buy_orders:
            best_bid = max(order_depth.buy_orders.keys())
            available = order_depth.buy_orders[best_bid]
            if best_bid > fair_value:
                quantity = min(available, position_limit + position, self.max_trade_volume)
                if quantity > 0:
                    orders.append(Order("CROISSANT", best_bid, -quantity))
        return orders

    def jam_orders(self, order_depth: OrderDepth, position: int, position_limit: int) -> List[Order]:
        orders: List[Order] = []
        fair_value = self.jam_fair_value(order_depth)
        if order_depth.sell_orders:
            best_ask = min(order_depth.sell_orders.keys())
            available = -order_depth.sell_orders[best_ask]
            if best_ask < fair_value:
                quantity = min(available, position_limit - position, self.max_trade_volume)
                if quantity > 0:
                    orders.append(Order("JAM", best_ask, quantity))
        if order_depth.buy_orders:
            best_bid = max(order_depth.buy_orders.keys())
            available = order_depth.buy_orders[best_bid]
            if best_bid > fair_value:
                quantity = min(available, position_limit + position, self.max_trade_volume)
                if quantity > 0:
                    orders.append(Order("JAM", best_bid, -quantity))
        return orders

    def djembe_orders(self, order_depth: OrderDepth, position: int, position_limit: int) -> List[Order]:
        orders: List[Order] = []
        fair_value = self.djembe_fair_value(order_depth)
        if order_depth.sell_orders:
            best_ask = min(order_depth.sell_orders.keys())
            available = -order_depth.sell_orders[best_ask]
            if best_ask < fair_value:
                quantity = min(available, position_limit - position, self.max_trade_volume)
                if quantity > 0:
                    orders.append(Order("DJEMBE", best_ask, quantity))
        if order_depth.buy_orders:
            best_bid = max(order_depth.buy_orders.keys())
            available = order_depth.buy_orders[best_bid]
            if best_bid > fair_value:
                quantity = min(available, position_limit + position, self.max_trade_volume)
                if quantity > 0:
                    orders.append(Order("DJEMBE", best_bid, -quantity))
        return orders

    def basket1_orders(self, order_depths: dict, position: int, position_limit: int) -> List[Order]:
        """
        For PICNIC_BASKET1, composed of:
          6 CROISSANTS, 3 JAM, 1 DJEMBE.
        """
        croissant_depth = order_depths["CROISSANT"]
        jam_depth = order_depths["JAM"]
        djembe_depth = order_depths["DJEMBE"]
        basket_depth = order_depths["PICNIC_BASKET1"]

        synthetic_fv = 6 * self.croissant_fair_value(croissant_depth) + \
                       3 * self.jam_fair_value(jam_depth) + \
                       1 * self.djembe_fair_value(djembe_depth)
        orders = []
        if basket_depth.sell_orders:
            best_ask = min(basket_depth.sell_orders.keys())
            available = -basket_depth.sell_orders[best_ask]
            if best_ask < synthetic_fv:
                quantity = min(available, position_limit - position, self.max_trade_volume)
                if quantity > 0:
                    orders.append(Order("PICNIC_BASKET1", best_ask, quantity))
        if basket_depth.buy_orders:
            best_bid = max(basket_depth.buy_orders.keys())
            available = basket_depth.buy_orders[best_bid]
            if best_bid > synthetic_fv:
                quantity = min(available, position_limit + position, self.max_trade_volume)
                if quantity > 0:
                    orders.append(Order("PICNIC_BASKET1", best_bid, -quantity))
        return orders

    def basket2_orders(self, order_depths: dict, position: int, position_limit: int) -> List[Order]:
        """
        For PICNIC_BASKET2, composed of:
          4 CROISSANTS, 2 JAM.
        """
        croissant_depth = order_depths["CROISSANT"]
        jam_depth = order_depths["JAM"]
        basket_depth = order_depths["PICNIC_BASKET2"]

        synthetic_fv = 4 * self.croissant_fair_value(croissant_depth) + \
                       2 * self.jam_fair_value(jam_depth)
        orders = []
        if basket_depth.sell_orders:
            best_ask = min(basket_depth.sell_orders.keys())
            available = -basket_depth.sell_orders[best_ask]
            if best_ask < synthetic_fv:
                quantity = min(available, position_limit - position, self.max_trade_volume)
                if quantity > 0:
                    orders.append(Order("PICNIC_BASKET2", best_ask, quantity))
        if basket_depth.buy_orders:
            best_bid = max(basket_depth.buy_orders.keys())
            available = basket_depth.buy_orders[best_bid]
            if best_bid > synthetic_fv:
                quantity = min(available, position_limit + position, self.max_trade_volume)
                if quantity > 0:
                    orders.append(Order("PICNIC_BASKET2", best_bid, -quantity))
        return orders

    # HELPER: CLEAR POSITION (Shared across strategies)
    def clear_position_order(self, orders: List[Order], order_depth: OrderDepth,
                             position: int, position_limit: int, product: str,
                             buy_order_volume: int, sell_order_volume: int,
                             fair_value: float, width: int) -> (int, int):
        position_after = position + buy_order_volume - sell_order_volume
        fair_bid = math.floor(fair_value)
        fair_ask = math.ceil(fair_value)
        buy_capacity  = position_limit - (position + buy_order_volume)
        sell_capacity = position_limit + (position - sell_order_volume)
        if position_after > 0:
            if fair_ask in order_depth.buy_orders:
                clear_qty = min(order_depth.buy_orders[fair_ask], position_after)
                qty_to_sell = min(sell_capacity, clear_qty)
                if qty_to_sell > 0:
                    orders.append(Order(product, fair_ask, -abs(qty_to_sell)))
                    sell_order_volume += abs(qty_to_sell)
        elif position_after < 0:
            if fair_bid in order_depth.sell_orders:
                clear_qty = min(abs(order_depth.sell_orders[fair_bid]), abs(position_after))
                qty_to_buy = min(buy_capacity, clear_qty)
                if qty_to_buy > 0:
                    orders.append(Order(product, fair_bid, qty_to_buy))
                    buy_order_volume += abs(qty_to_buy)
        return buy_order_volume, sell_order_volume

    # 6) MANUAL CHALLENGE – FLIPPERS (Placeholder)
    def flippers_bid_strategy(self, state: TradingState) -> float:
        """
        A placeholder approach that tracks second–best bids and computes an optimal bid.
        """
        if not self.flipper_second_bids:
            return 200.0  # Default bid
        avg_so_far = sum(self.flipper_second_bids) / len(self.flipper_second_bids)
        best_bid = min(320, max(160, avg_so_far - 10))
        return best_bid

    # 7) MAIN RUN (ENTRY POINT)
    def run(self, state: TradingState):
        try:
            result = {}
            # --- Round 2 Products ---
            resin_position_limit = 50
            kelp_position_limit = 50
            squidink_position_limit = 50
            kelp_make_width = 3.5
            kelp_take_width = 1
            timespan = 10  # historical steps for KELP

            # RAINFOREST_RESIN orders:
            if "RAINFOREST_RESIN" in state.order_depths:
                resin_position = state.position.get("RAINFOREST_RESIN", 0)
                resin_orders = self.resin_orders(
                    state.order_depths["RAINFOREST_RESIN"],
                    fair_value=10000,  # fixed value
                    width=2,
                    position=resin_position,
                    position_limit=resin_position_limit
                )
                result["RAINFOREST_RESIN"] = resin_orders

            # KELP orders:
            if "KELP" in state.order_depths:
                kelp_position = state.position.get("KELP", 0)
                kelp_orders = self.kelp_orders(
                    state.order_depths["KELP"],
                    timespan,
                    kelp_make_width,
                    kelp_take_width,
                    kelp_position,
                    kelp_position_limit
                )
                result["KELP"] = kelp_orders

            # SQUID_INK orders:
            if "SQUID_INK" in state.order_depths:
                squidink_position = state.position.get("SQUID_INK", 0)
                squidink_orders = self.squidink_utility_orders(
                    state.order_depths["SQUID_INK"],
                    position=squidink_position,
                    position_limit=squidink_position_limit,
                    fair_value_base=2000,
                    candidate_range=2
                )
                result["SQUID_INK"] = squidink_orders

            # --- Bread/Jam/Djembe/Baskets ---
            pos_limits = {
                "CROISSANT": 250,
                "JAM": 350,
                "DJEMBE": 60,
                "PICNIC_BASKET1": 60,
                "PICNIC_BASKET2": 100,
            }
            if "CROISSANT" in state.order_depths:
                pos = state.position.get("CROISSANT", 0)
                result["CROISSANT"] = self.croissant_orders(
                    state.order_depths["CROISSANT"], pos, pos_limits["CROISSANT"]
                )
            if "JAM" in state.order_depths:
                pos = state.position.get("JAM", 0)
                result["JAM"] = self.jam_orders(
                    state.order_depths["JAM"], pos, pos_limits["JAM"]
                )
            if "DJEMBE" in state.order_depths:
                pos = state.position.get("DJEMBE", 0)
                result["DJEMBE"] = self.djembe_orders(
                    state.order_depths["DJEMBE"], pos, pos_limits["DJEMBE"]
                )
            if all(p in state.order_depths for p in ["CROISSANT", "DJEMBE", "JAM", "PICNIC_BASKET1"]):
                basket_position = state.position.get("PICNIC_BASKET1", 0)
                result["PICNIC_BASKET1"] = self.basket1_orders(
                    state.order_depths,
                    basket_position,
                    pos_limits["PICNIC_BASKET1"]
                )
            if all(p in state.order_depths for p in ["CROISSANT", "DJEMBE", "JAM", "PICNIC_BASKET2"]):
                basket_position = state.position.get("PICNIC_BASKET2", 0)
                result["PICNIC_BASKET2"] = self.basket2_orders(
                    state.order_depths,
                    basket_position,
                    pos_limits["PICNIC_BASKET2"]
                )

            # --- Volcanic Rock Vouchers ---
            for voucher_product in self.volcanic_voucher_config.keys():
                if voucher_product in state.order_depths:
                    pos = state.position.get(voucher_product, 0)
                    voucher_orders = self.volcanic_voucher_orders(
                        voucher_product, state.order_depths[voucher_product], pos
                    )
                    if voucher_orders:
                        result[voucher_product] = voucher_orders

            # --- LP Conversion Arbitrage ---
            prices = {}
            for prod, fallback in [("CROISSANT", 4300), ("JAM", 6600), ("DJEMBE", 13400)]:
                if prod in state.order_depths:
                    prices[prod] = self.mid_price(state.order_depths[prod], fallback)
                else:
                    prices[prod] = fallback
            if "PICNIC_BASKET1" in state.order_depths:
                prices["PICNIC_BASKET1"] = self.mid_price(
                    state.order_depths["PICNIC_BASKET1"],
                    6 * prices["CROISSANT"] + 3 * prices["JAM"] + prices["DJEMBE"]
                )
            else:
                prices["PICNIC_BASKET1"] = 6 * prices["CROISSANT"] + 3 * prices["JAM"] + prices["DJEMBE"]
            if "PICNIC_BASKET2" in state.order_depths:
                prices["PICNIC_BASKET2"] = self.mid_price(
                    state.order_depths["PICNIC_BASKET2"],
                    4 * prices["CROISSANT"] + 2 * prices["JAM"]
                )
            else:
                prices["PICNIC_BASKET2"] = 4 * prices["CROISSANT"] + 2 * prices["JAM"]

            lp_decision, lp_profit = self.optimize_conversion_arbitrage(prices, pos_limits)
            conversion_orders = self.decompose_lp_conversion_orders(state, prices, lp_decision)
            for order in conversion_orders:
                if order.symbol in result:
                    result[order.symbol].append(order)
                else:
                    result[order.symbol] = [order]

            # --- FLIPPERS (Optional) ---
            if "FLIPPERS" in state.order_depths:
                od = state.order_depths["FLIPPERS"]
                if len(od.buy_orders) >= 2:
                    sorted_bids = sorted(od.buy_orders.keys(), reverse=True)
                    second_bid_price = sorted_bids[1]
                    self.flipper_second_bids.append(second_bid_price)
                # Uncomment the following lines to place a bid(but we dont want it i think)
                # your_bid = self.flippers_bid_strategy(state)
                # result["FLIPPERS"] = [Order("FLIPPERS", your_bid, 10)]

            # Build traderData for later analysis and plotting.
            traderData = jsonpickle.encode({
                "kelp_prices": self.kelp_prices,
                "kelp_vwap": self.kelp_vwap,
                "squidink_prices": self.squidink_prices,
                "flipper_second_bids": self.flipper_second_bids,
            })

            conversions = 1  # or any relevant conversion count

            if plt is not None:
                self.plot_history(self.kelp_prices, self.kelp_vwap)

            return result, conversions, traderData

        except Exception as e:
            print("Exception in trader.run:", e)
            return {}, 0, ""