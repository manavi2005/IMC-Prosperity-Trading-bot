# -*- coding: utf-8 -*-
"""UsingHInt.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ldr47d_zrQpX-dOmnwBanQQETPn6Pu6q
"""

# -*- coding: utf-8 -*-
"""Graded Trading Bot Code

This implementation includes:
- Resin strategy (fixed fair value)
- Kelp strategy (with volume-weighted fair value calculation and historical tracking)
- Squid Ink strategy with mean reversion enhancements:
    • Computes a moving average and standard deviation from recent Squid Ink fair values.
    • Uses a z–score to adjust utility so that trades favor short-term reversion.
- Execution realism adjustments via execution_slippage and transaction_cost.
- Adjustable risk_coefficient and maximum trade volume.
"""

from datamodel import OrderDepth, TradingState, Order
from typing import List
import jsonpickle
import math

try:
    import matplotlib.pyplot as plt
except ImportError:
    plt = None

class Trader:
    def __init__(self,
                 execution_slippage: float = 0.2,    # Lower slippage to encourage trading
                 transaction_cost: float = 0.2,        # Lower transaction cost penalty
                 risk_coefficient: float = 0.05,       # Lower risk penalty
                 max_trade_volume: int = 10,           # Increase max trade volume per order
                 reversion_coefficient: float = 0.5     # Coefficient for mean-reversion bonus
                ):
        self.execution_slippage = execution_slippage
        self.transaction_cost = transaction_cost
        self.risk_coefficient = risk_coefficient
        self.max_trade_volume = max_trade_volume
        self.reversion_coefficient = reversion_coefficient

        # Historical data trackers for visualization or computing metrics.
        self.kelp_prices = []        # Stores fair values for KELP.
        self.kelp_vwap = []          # Stores VWAP and volume info for KELP.
        self.squidink_prices = []    # Stores fair values for SQUID_INK.

    # 1) RESIN STRATEGY (Fixed fair value)
    def resin_orders(self, order_depth: OrderDepth, fair_value: int, width: int,
                     position: int, position_limit: int) -> List[Order]:
        orders: List[Order] = []
        buy_order_volume = 0
        sell_order_volume = 0

        # For Resin, we maintain a fixed fair value.
        fair_value = 10000

        if order_depth.sell_orders:
            best_ask = min(order_depth.sell_orders.keys())
            best_ask_amount = -order_depth.sell_orders[best_ask]
            if best_ask < fair_value:
                quantity = min(best_ask_amount, position_limit - position)
                if quantity > 0:
                    orders.append(Order("RAINFOREST_RESIN", best_ask, quantity))
                    buy_order_volume += quantity

        if order_depth.buy_orders:
            best_bid = max(order_depth.buy_orders.keys())
            best_bid_amount = order_depth.buy_orders[best_bid]
            if best_bid > fair_value:
                quantity = min(best_bid_amount, position_limit + position)
                if quantity > 0:
                    orders.append(Order("RAINFOREST_RESIN", best_bid, -quantity))
                    sell_order_volume += quantity

        buy_order_volume, sell_order_volume = self.clear_position_order(
            orders, order_depth, position, position_limit, "RAINFOREST_RESIN",
            buy_order_volume, sell_order_volume, fair_value, width=1
        )

        # Fill remaining capacity with passive orders.
        buy_quantity = position_limit - (position + buy_order_volume)
        if buy_quantity > 0:
            orders.append(Order("RAINFOREST_RESIN", fair_value - 1, buy_quantity))
        sell_quantity = position_limit + (position - sell_order_volume)
        if sell_quantity > 0:
            orders.append(Order("RAINFOREST_RESIN", fair_value + 1, -sell_quantity))

        return orders

    # 2) KELP STRATEGY
    def kelp_fair_value(self, order_depth: OrderDepth, method="volume_weighted") -> float:
        if not order_depth.sell_orders or not order_depth.buy_orders:
            return 2000  # fallback value

        best_ask = min(order_depth.sell_orders.keys())
        best_bid = max(order_depth.buy_orders.keys())
        if method == "volume_weighted":
            total_sell_volume = sum(abs(vol) for vol in order_depth.sell_orders.values())
            total_buy_volume = sum(abs(vol) for vol in order_depth.buy_orders.values())
            if total_sell_volume == 0 or total_buy_volume == 0:
                return 2000
            weighted_sell_price = sum(price * abs(vol) for price, vol in order_depth.sell_orders.items()) / total_sell_volume
            weighted_buy_price  = sum(price * abs(vol) for price, vol in order_depth.buy_orders.items()) / total_buy_volume
            return (weighted_sell_price + weighted_buy_price) / 2
        return (best_ask + best_bid) / 2

    def kelp_orders(self, order_depth: OrderDepth, timespan: int, width: float,
                    take_width: float, position: int, position_limit: int) -> List[Order]:
        orders: List[Order] = []
        buy_order_volume = 0
        sell_order_volume = 0

        if not order_depth.sell_orders or not order_depth.buy_orders:
            return orders

        best_ask = min(order_depth.sell_orders.keys())
        best_bid = max(order_depth.buy_orders.keys())
        fair_value = self.kelp_fair_value(order_depth, method="volume_weighted")

        volume = -order_depth.sell_orders[best_ask] + order_depth.buy_orders[best_bid]
        vwap = (best_bid * (-order_depth.sell_orders[best_ask]) +
                best_ask * order_depth.buy_orders[best_bid]) / volume

        # Track fair value and VWAP.
        self.kelp_vwap.append({"vol": volume, "vwap": vwap})
        self.kelp_prices.append(fair_value)

        # Keep history within the defined time window.
        if len(self.kelp_vwap) > timespan:
            self.kelp_vwap.pop(0)
        if len(self.kelp_prices) > timespan:
            self.kelp_prices.pop(0)

        if best_ask <= fair_value - take_width:
            ask_amount = -order_depth.sell_orders[best_ask]
            if ask_amount <= 20:
                quantity = min(ask_amount, position_limit - position)
                if quantity > 0:
                    orders.append(Order("KELP", best_ask, quantity))
                    buy_order_volume += quantity

        if best_bid >= fair_value + take_width:
            bid_amount = order_depth.buy_orders[best_bid]
            if bid_amount <= 20:
                quantity = min(bid_amount, position_limit + position)
                if quantity > 0:
                    orders.append(Order("KELP", best_bid, -quantity))
                    sell_order_volume += quantity

        buy_order_volume, sell_order_volume = self.clear_position_order(
            orders, order_depth, position, position_limit, "KELP",
            buy_order_volume, sell_order_volume, fair_value, width=2
        )

        # Passive order pricing.
        aaf = [price for price in order_depth.sell_orders.keys() if price > fair_value + 1]
        bbf = [price for price in order_depth.buy_orders.keys() if price < fair_value - 1]
        passive_sell_price = min(aaf) if aaf else fair_value + 2
        passive_buy_price = max(bbf) if bbf else fair_value - 2

        buy_quantity = position_limit - (position + buy_order_volume)
        if buy_quantity > 0:
            orders.append(Order("KELP", passive_buy_price + 1, buy_quantity))
        sell_quantity = position_limit + (position - sell_order_volume)
        if sell_quantity > 0:
            orders.append(Order("KELP", passive_sell_price - 1, -sell_quantity))
        return orders

    # 3) SQUID INK STRATEGY WITH MEAN REVERSION
    def squidink_fair_value(self, order_depth: OrderDepth, method="volume_weighted") -> float:
        if not order_depth.sell_orders or not order_depth.buy_orders:
            return 2000
        best_ask = min(order_depth.sell_orders.keys())
        best_bid = max(order_depth.buy_orders.keys())
        if method == "volume_weighted":
            total_sell_volume = sum(abs(vol) for vol in order_depth.sell_orders.values())
            total_buy_volume = sum(abs(vol) for vol in order_depth.buy_orders.values())
            if total_sell_volume == 0 or total_buy_volume == 0:
                return 2000
            weighted_sell_price = sum(price * abs(vol) for price, vol in order_depth.sell_orders.items()) / total_sell_volume
            weighted_buy_price  = sum(price * abs(vol) for price, vol in order_depth.buy_orders.items()) / total_buy_volume
            return (weighted_sell_price + weighted_buy_price) / 2
        return (best_ask + best_bid) / 2

    def compute_swing_metric(self, window: int = 10) -> (float, float):
        """Compute the moving average and standard deviation for the recent Squid Ink fair values."""
        recent = self.squidink_prices[-window:] if len(self.squidink_prices) >= window else self.squidink_prices
        if not recent:
            return 0, 0
        avg = sum(recent) / len(recent)
        variance = sum((x - avg) ** 2 for x in recent) / len(recent)
        std = math.sqrt(variance)
        return avg, std

    def squidink_utility_orders(self, order_depth: OrderDepth, position: int, position_limit: int,
                                fair_value_base: float = 2000, candidate_range: int = 2) -> List[Order]:
        orders: List[Order] = []
        fair_value = self.squidink_fair_value(order_depth, method="volume_weighted")
        if fair_value == 0:
            fair_value = fair_value_base

        # Record the raw fair value.
        self.squidink_prices.append(fair_value)
        # Compute recent average and volatility.
        avg, std = self.compute_swing_metric(window=10)
        z = (fair_value - avg) / std if std > 0 else 0  # z-score of current price

        candidate_prices = [int(fair_value + offset) for offset in range(-candidate_range, candidate_range + 1)]
        best_buy_price = None
        best_buy_utility = float("-inf")
        best_sell_price = None
        best_sell_utility = float("-inf")

        best_ask = min(order_depth.sell_orders.keys()) if order_depth.sell_orders else None
        best_bid = max(order_depth.buy_orders.keys()) if order_depth.buy_orders else None

        for price in candidate_prices:
            if price < fair_value:
                distance = best_ask - price if best_ask is not None else candidate_range
                exec_prob = max(0, 1 - (distance / candidate_range))
                profit = fair_value - price - self.execution_slippage - self.transaction_cost
                penalty = self.risk_coefficient * abs(position + 1)
                base_utility = (profit - penalty) * exec_prob
                # If oversold (negative z), add bonus proportional to its magnitude.
                bonus = self.reversion_coefficient * (-z) if z < 0 else 0
                utility = base_utility + bonus
                if utility > best_buy_utility:
                    best_buy_utility = utility
                    best_buy_price = price

            if price > fair_value:
                distance = price - best_bid if best_bid is not None else candidate_range
                exec_prob = max(0, 1 - (distance / candidate_range))
                profit = price - fair_value - self.execution_slippage - self.transaction_cost
                penalty = self.risk_coefficient * abs(position - 1)
                base_utility = (profit - penalty) * exec_prob
                # If overbought (positive z), add bonus proportional to z.
                bonus = self.reversion_coefficient * z if z > 0 else 0
                utility = base_utility + bonus
                if utility > best_sell_utility:
                    best_sell_utility = utility
                    best_sell_price = price

        buy_volume = min(self.max_trade_volume, position_limit - position)
        sell_volume = min(self.max_trade_volume, position_limit + position)
        if best_buy_price is not None and buy_volume > 0:
            orders.append(Order("SQUID_INK", best_buy_price, buy_volume))
        if best_sell_price is not None and sell_volume > 0:
            orders.append(Order("SQUID_INK", best_sell_price, -sell_volume))
        return orders

    # 4) CLEAR POSITION HELPER (Shared Across Products)
    def clear_position_order(self, orders: List[Order], order_depth: OrderDepth,
                             position: int, position_limit: int, product: str,
                             buy_order_volume: int, sell_order_volume: int,
                             fair_value: float, width: int) -> (int, int):
        position_after = position + buy_order_volume - sell_order_volume
        fair_bid = math.floor(fair_value)
        fair_ask = math.ceil(fair_value)
        buy_capacity  = position_limit - (position + buy_order_volume)
        sell_capacity = position_limit + (position - sell_order_volume)
        if position_after > 0:
            if fair_ask in order_depth.buy_orders:
                clear_qty = min(order_depth.buy_orders[fair_ask], position_after)
                qty_to_sell = min(sell_capacity, clear_qty)
                if qty_to_sell > 0:
                    orders.append(Order(product, fair_ask, -abs(qty_to_sell)))
                    sell_order_volume += abs(qty_to_sell)
        elif position_after < 0:
            if fair_bid in order_depth.sell_orders:
                clear_qty = min(abs(order_depth.sell_orders[fair_bid]), abs(position_after))
                qty_to_buy = min(buy_capacity, clear_qty)
                if qty_to_buy > 0:
                    orders.append(Order(product, fair_bid, qty_to_buy))
                    buy_order_volume += abs(qty_to_buy)
        return buy_order_volume, sell_order_volume

    # 5) MAIN RUN (ENTRY POINT)
    def run(self, state: TradingState):
        result = {}

        resin_position_limit = 50
        kelp_position_limit = 50
        squidink_position_limit = 50

        kelp_make_width = 3.5
        kelp_take_width = 1
        timespan = 10  # number of historical steps to store

        if "RAINFOREST_RESIN" in state.order_depths:
            resin_position = state.position.get("RAINFOREST_RESIN", 0)
            resin_orders = self.resin_orders(
                state.order_depths["RAINFOREST_RESIN"],
                fair_value=10000,  # fixed fair value for Resin
                width=2,
                position=resin_position,
                position_limit=resin_position_limit
            )
            result["RAINFOREST_RESIN"] = resin_orders

        if "KELP" in state.order_depths:
            kelp_position = state.position.get("KELP", 0)
            kelp_orders = self.kelp_orders(
                state.order_depths["KELP"],
                timespan,
                kelp_make_width,
                kelp_take_width,
                kelp_position,
                kelp_position_limit
            )
            result["KELP"] = kelp_orders

        if "SQUID_INK" in state.order_depths:
            squidink_position = state.position.get("SQUID_INK", 0)
            squidink_orders = self.squidink_utility_orders(
                state.order_depths["SQUID_INK"],
                position=squidink_position,
                position_limit=squidink_position_limit,
                fair_value_base=2000,
                candidate_range=2
            )
            result["SQUID_INK"] = squidink_orders

        traderData = jsonpickle.encode({
            "kelp_prices": self.kelp_prices,
            "kelp_vwap": self.kelp_vwap,
            "squidink_prices": self.squidink_prices
        })
        conversions = 1

        if plt is not None:
            self.plot_history(self.kelp_prices, self.kelp_vwap)

        return result, conversions, traderData