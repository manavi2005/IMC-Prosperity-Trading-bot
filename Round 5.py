# -*- coding: utf-8 -*-
"""Round4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1E-zc7882BWJm4ExoOjDWqN1IgIDut-dT
"""

from datamodel import OrderDepth, TradingState, Order, ConversionObservation
from typing import List, Tuple, Dict
import jsonpickle
import math

MACARONS = "MAGNIFICENT_MACARONS"
MACARONS_LIMIT = 75
MACARONS_CONV_LIMIT = 10
MACARONS_EDGE = 2
MACARONS_PROB = 0.8

#                  UTILITY FUNCTIONS

def black_scholes_call_price(S: float, K: float, T: float, r: float, sigma: float) -> float:
    """
    Compute the price of a European call using Black–Scholes formula.
    S     = spot price of underlying
    K     = strike price
    T     = time to maturity (in years or fraction if 7 days is e.g. 7/365)
    r     = risk-free interest rate
    sigma = implied volatility
    """
    # To keep it simple in the game environment, you might treat T as # of days / 365
    # or just treat T=7 “units,” r=0, etc. for a rough approach.

    from math import log, sqrt, exp, erf

    # If T=0 or sigma=0, the formula breaks down, so add small floors
    T = max(T, 1e-9)
    sigma = max(sigma, 1e-9)

    # Standard Black-Scholes d1, d2
    d1 = (math.log(S / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * math.sqrt(T))
    d2 = d1 - sigma * math.sqrt(T)

    # Cumulative distribution for standard normal
    def cdf(x):
        return 0.5 * (1 + math.erf(x / math.sqrt(2)))

    call_val = S * cdf(d1) - K * math.exp(-r * T) * cdf(d2)
    return call_val


class Trader:
    def __init__(self,
                 execution_slippage: float = 0.2,     # Lower slippage to encourage trading
                 transaction_cost: float = 0.2,       # Lower transaction cost penalty
                 risk_coefficient: float = 0.05,      # Lower risk penalty
                 max_trade_volume: int = 10,          # Increase max trade volume per order
                 reversion_coefficient: float = 0.5
                ):
        self.execution_slippage = execution_slippage
        self.transaction_cost = transaction_cost
        self.risk_coefficient = risk_coefficient
        self.max_trade_volume = max_trade_volume
        self.reversion_coefficient = reversion_coefficient

        # Historical data trackers for visualization or computing metrics.
        self.kelp_prices = []        # Stores fair values for KELP.
        self.kelp_vwap = []          # Stores VWAP and volume info for KELP.
        self.squidink_prices = []    # Stores fair values for SQUID_INK.

        self.flipper_second_bids = [] 

        # Configure the Volcanic Rock Vouchers
        # We assume T=7 days, a placeholder for “time to expiry,” r=0, and sigma=0.2 by default
        self.volcanic_voucher_config = {
            "VOLCANIC_ROCK_VOUCHER_9500":  {"strike": 9500,  "limit": 300, "T": 7, "r": 0.0, "sigma": 0.2},
            "VOLCANIC_ROCK_VOUCHER_9750":  {"strike": 9750,  "limit": 200, "T": 7, "r": 0.0, "sigma": 0.2},
            "VOLCANIC_ROCK_VOUCHER_10000": {"strike": 10000, "limit": 200, "T": 7, "r": 0.0, "sigma": 0.2},
            "VOLCANIC_ROCK_VOUCHER_10250": {"strike": 10250, "limit": 200, "T": 7, "r": 0.0, "sigma": 0.2},
            "VOLCANIC_ROCK_VOUCHER_10500": {"strike": 10500, "limit": 200, "T": 7, "r": 0.0, "sigma": 0.2},
        }

    # 1) RESIN STRATEGY (Fixed fair value)
    def resin_orders(self, order_depth: OrderDepth, fair_value: int, width: int,
                     position: int, position_limit: int) -> List[Order]:
        orders: List[Order] = []
        buy_order_volume = 0
        sell_order_volume = 0

        # For Resin, we maintain a fixed fair value = 10000
        fair_value = 10000

        if order_depth.sell_orders:
            best_ask = min(order_depth.sell_orders.keys())
            best_ask_amount = -order_depth.sell_orders[best_ask]
            if best_ask < fair_value:
                quantity = min(best_ask_amount, position_limit - position)
                if quantity > 0:
                    orders.append(Order("RAINFOREST_RESIN", round(best_ask), quantity))
                    buy_order_volume += quantity

        if order_depth.buy_orders:
            best_bid = max(order_depth.buy_orders.keys())
            best_bid_amount = order_depth.buy_orders[best_bid]
            if best_bid > fair_value:
                quantity = min(best_bid_amount, position_limit + position)
                if quantity > 0:
                    orders.append(Order("RAINFOREST_RESIN", round(best_bid), -quantity))
                    sell_order_volume += quantity

        buy_order_volume, sell_order_volume = self.clear_position_order(
            orders, order_depth, position, position_limit, "RAINFOREST_RESIN",
            buy_order_volume, sell_order_volume, fair_value, width=1
        )

        # Fill remaining capacity with passive orders.
        buy_quantity = position_limit - (position + buy_order_volume)
        if buy_quantity > 0:
            orders.append(Order("RAINFOREST_RESIN", round(fair_value - 1), buy_quantity))
        sell_quantity = position_limit + (position - sell_order_volume)
        if sell_quantity > 0:
            orders.append(Order("RAINFOREST_RESIN", round(fair_value + 1), -sell_quantity))

        return orders

    # 2) KELP STRATEGY
    def kelp_fair_value(self, order_depth: OrderDepth, method="volume_weighted") -> float:
        if not order_depth.sell_orders or not order_depth.buy_orders:
            return 2000  # fallback value

        best_ask = min(order_depth.sell_orders.keys())
        best_bid = max(order_depth.buy_orders.keys())
        if method == "volume_weighted":
            total_sell_volume = sum(abs(vol) for vol in order_depth.sell_orders.values())
            total_buy_volume = sum(abs(vol) for vol in order_depth.buy_orders.values())
            if total_sell_volume == 0 or total_buy_volume == 0:
                return 2000
            weighted_sell_price = sum(price * abs(vol) for price, vol in order_depth.sell_orders.items()) / total_sell_volume
            weighted_buy_price  = sum(price * abs(vol) for price, vol in order_depth.buy_orders.items()) / total_buy_volume
            return (weighted_sell_price + weighted_buy_price) / 2
        return (best_ask + best_bid) / 2

    def kelp_orders(self, order_depth: OrderDepth, timespan: int, width: float,
                    take_width: float, position: int, position_limit: int) -> List[Order]:
        orders: List[Order] = []
        buy_order_volume = 0
        sell_order_volume = 0

        if not order_depth.sell_orders or not order_depth.buy_orders:
            return orders

        best_ask = min(order_depth.sell_orders.keys())
        best_bid = max(order_depth.buy_orders.keys())
        fair_value = self.kelp_fair_value(order_depth, method="volume_weighted")

        volume = -order_depth.sell_orders[best_ask] + order_depth.buy_orders[best_bid]
        vwap = (best_bid * (-order_depth.sell_orders[best_ask]) +
                best_ask * order_depth.buy_orders[best_bid]) / volume

        # Track fair value and VWAP.
        self.kelp_vwap.append({"vol": volume, "vwap": vwap})
        self.kelp_prices.append(fair_value)

        # Keep history within the defined time window.
        if len(self.kelp_vwap) > timespan:
            self.kelp_vwap.pop(0)
        if len(self.kelp_prices) > timespan:
            self.kelp_prices.pop(0)

        # Aggressive buy if best_ask is well below fair_value
        if best_ask <= fair_value - take_width:
            ask_amount = -order_depth.sell_orders[best_ask]
            if ask_amount <= 20:
                quantity = min(ask_amount, position_limit - position)
                if quantity > 0:
                    orders.append(Order("KELP", round(best_ask), quantity))
                    buy_order_volume += quantity

        # Aggressive sell if best_bid is well above fair_value
        if best_bid >= fair_value + take_width:
            bid_amount = order_depth.buy_orders[best_bid]
            if bid_amount <= 20:
                quantity = min(bid_amount, position_limit + position)
                if quantity > 0:
                    orders.append(Order("KELP", round(best_bid), -quantity))
                    sell_order_volume += quantity

        buy_order_volume, sell_order_volume = self.clear_position_order(
            orders, order_depth, position, position_limit, "KELP",
            buy_order_volume, sell_order_volume, fair_value, width=2
        )

        # Passive order pricing.
        aaf = [price for price in order_depth.sell_orders.keys() if price > fair_value + 1]
        bbf = [price for price in order_depth.buy_orders.keys() if price < fair_value - 1]
        passive_sell_price = min(aaf) if aaf else fair_value + 2
        passive_buy_price = max(bbf) if bbf else fair_value - 2

        buy_quantity = position_limit - (position + buy_order_volume)
        if buy_quantity > 0:
            orders.append(Order("KELP", round(passive_buy_price + 1), buy_quantity))
        sell_quantity = position_limit + (position - sell_order_volume)
        if sell_quantity > 0:
            orders.append(Order("KELP", round(passive_sell_price - 1), -sell_quantity))
        return orders

    # 3) SQUID INK STRATEGY WITH MEAN REVERSION
    def squidink_fair_value(self, order_depth: OrderDepth, method="volume_weighted") -> float:
        if not order_depth.sell_orders or not order_depth.buy_orders:
            return 2000
        best_ask = min(order_depth.sell_orders.keys())
        best_bid = max(order_depth.buy_orders.keys())
        if method == "volume_weighted":
            total_sell_volume = sum(abs(vol) for vol in order_depth.sell_orders.values())
            total_buy_volume = sum(abs(vol) for vol in order_depth.buy_orders.values())
            if total_sell_volume == 0 or total_buy_volume == 0:
                return 2000
            weighted_sell_price = sum(price * abs(vol) for price, vol in order_depth.sell_orders.items()) / total_sell_volume
            weighted_buy_price  = sum(price * abs(vol) for price, vol in order_depth.buy_orders.items()) / total_buy_volume
            return (weighted_sell_price + weighted_buy_price) / 2
        return (best_ask + best_bid) / 2

    def compute_swing_metric(self, window: int = 10) -> Tuple[float, float]:
        """Compute the moving average and standard deviation for the recent Squid Ink fair values."""
        recent = self.squidink_prices[-window:] if len(self.squidink_prices) >= window else self.squidink_prices
        if not recent:
            return 0, 0
        avg = sum(recent) / len(recent)
        variance = sum((x - avg) ** 2 for x in recent) / len(recent)
        std = math.sqrt(variance)
        return avg, std

    def mid_price(self, order_depth: OrderDepth, fallback: float) -> float:
        if not order_depth.sell_orders or not order_depth.buy_orders:
            return fallback
        best_ask = min(order_depth.sell_orders.keys())
        best_bid = max(order_depth.buy_orders.keys())
        return (best_ask + best_bid) / 2

    def optimize_conversion_arbitrage(self, prices: dict, position_limits: dict) -> Tuple[dict, float]:
        """
        A math‐only approach that “solves” a linear program for baskets vs. components.
        We keep it simple for demonstration.
        """
        items = ["CROISSANT", "JAM", "DJEMBE", "PICNIC_BASKET1", "PICNIC_BASKET2"]
        fv_c = prices["CROISSANT"]
        fv_j = prices["JAM"]
        fv_d = prices["DJEMBE"]
        synthetic_b1 = 6 * fv_c + 3 * fv_j + 1 * fv_d
        synthetic_b2 = 4 * fv_c + 2 * fv_j

        # Construct the advantage vector
        adv = [
            prices["CROISSANT"] - fv_c,
            prices["JAM"] - fv_j,
            prices["DJEMBE"] - fv_d,
            prices["PICNIC_BASKET1"] - synthetic_b1,
            prices["PICNIC_BASKET2"] - synthetic_b2,
        ]

        decision = {}
        total_profit = 0
        for i, item in enumerate(items):
            limit = position_limits[item]
            if adv[i] > 0:
                decision[item] = limit
                total_profit += adv[i] * limit
            elif adv[i] < 0:
                decision[item] = -limit
                total_profit += adv[i] * (-limit)
            else:
                decision[item] = 0

        return decision, total_profit

    # Helper: Decompose LP Decision into Executable Orders
    def decompose_lp_conversion_orders(self, state: TradingState, prices: dict, lp_decision: dict) -> List[Order]:
        """
        Using the LP conversion decision and current positions, compute the orders needed to adjust positions.
        For each product, if the LP target differs from the current position, generate an order at
        best available price.
        """
        conversion_orders = []
        for product, target_net in lp_decision.items():
            current_position = state.position.get(product, 0)
            order_volume = target_net - current_position
            # Only trade if the adjustment is nonzero.
            if abs(order_volume) < 1:
                continue

            # Determine order price using the order depth if available.
            if product in state.order_depths:
                od = state.order_depths[product]
                if order_volume > 0 and od.sell_orders:
                    price = min(od.sell_orders.keys())
                elif order_volume < 0 and od.buy_orders:
                    price = max(od.buy_orders.keys())
                else:
                    price = prices.get(product, 1000)  # fallback
            else:
                price = prices.get(product, 1000)
            conversion_orders.append(Order(product, round(price), int(order_volume)))
        return conversion_orders

    def squidink_utility_orders(self, order_depth: OrderDepth, position: int, position_limit: int,
                                fair_value_base: float = 2000, candidate_range: int = 2) -> List[Order]:
        orders: List[Order] = []
        fair_value = self.squidink_fair_value(order_depth, method="volume_weighted")
        if fair_value == 0:
            fair_value = fair_value_base

        # Record the raw fair value.
        self.squidink_prices.append(fair_value)
        # Compute recent average and volatility.
        avg, std = self.compute_swing_metric(window=10)
        z = (fair_value - avg) / std if std > 0 else 0  # z-score

        candidate_prices = [int(fair_value + offset) for offset in range(-candidate_range, candidate_range + 1)]
        best_buy_price = None
        best_buy_utility = float("-inf")
        best_sell_price = None
        best_sell_utility = float("-inf")

        best_ask = min(order_depth.sell_orders.keys()) if order_depth.sell_orders else None
        best_bid = max(order_depth.buy_orders.keys()) if order_depth.buy_orders else None

        for price in candidate_prices:
            if best_ask is not None and price < fair_value:
                distance = best_ask - price
                exec_prob = max(0, 1 - (distance / candidate_range))
                profit = fair_value - price - self.execution_slippage - self.transaction_cost
                penalty = self.risk_coefficient * abs(position + 1)
                base_utility = (profit - penalty) * exec_prob
                # If oversold (negative z), add reversion bonus
                bonus = self.reversion_coefficient * (-z) if z < 0 else 0
                utility = base_utility + bonus
                if utility > best_buy_utility:
                    best_buy_utility = utility
                    best_buy_price = price

            if best_bid is not None and price > fair_value:
                distance = price - best_bid
                exec_prob = max(0, 1 - (distance / candidate_range))
                profit = price - fair_value - self.execution_slippage - self.transaction_cost
                penalty = self.risk_coefficient * abs(position - 1)
                base_utility = (profit - penalty) * exec_prob
                # If overbought (positive z), add reversion bonus
                bonus = self.reversion_coefficient * z if z > 0 else 0
                utility = base_utility + bonus
                if utility > best_sell_utility:
                    best_sell_utility = utility
                    best_sell_price = price

        buy_volume = min(self.max_trade_volume, position_limit - position)
        sell_volume = min(self.max_trade_volume, position_limit + position)
        if best_buy_price is not None and buy_volume > 0:
            orders.append(Order("SQUID_INK", best_buy_price, buy_volume))
        if best_sell_price is not None and sell_volume > 0:
            orders.append(Order("SQUID_INK", round(best_sell_price), -sell_volume))
        return orders

    # 4) NEW: VOLCANIC ROCK VOUCHERS
    def volcanic_voucher_orders(self, product: str, order_depth: OrderDepth,
                                position: int) -> List[Order]:
        """
        Simple Black–Scholes approach for each VOLCANIC_ROCK_VOUCHER_x product.
        We treat them as (cash-settled) call options on some "VOLCANIC_ROCK" underlying
        whose current “spot price” we must infer or guess.

        We'll do a naive approach:
          - Assume a placeholder for 'S' (the underlying 'VOLCANIC_ROCK' spot),
            or if you have a real order book for "VOLCANIC_ROCK", you can mid-price that.
          - Compare best_ask and best_bid vs. Black–Scholes call price.
          - If ask < theoretical, buy. If bid > theoretical, sell.
        """
        orders: List[Order] = []
        config = self.volcanic_voucher_config[product]
        strike = config["strike"]
        position_limit = config["limit"]
        T = config["T"]
        r = config["r"]
        sigma = config["sigma"]

        # Naive assumption for the underlying price S:
        # If you actually have an order_depth for "VOLCANIC_ROCK", do a mid_price or volume-weighted.
        # For now, let's guess underlying is ~ 10,000:
        S = 10000.0

        # Compute a simplistic “fair value” via Black–Scholes
        # Time T is in 'days', we might convert T to fraction of year => T_years = T / 365
        T_years = T / 365.0

        theoretical_price = black_scholes_call_price(S, strike, T_years, r, sigma)

        # Now see if best_ask < theoretical => buy, best_bid > theoretical => sell
        if order_depth.sell_orders:
            best_ask = min(order_depth.sell_orders.keys())
            best_ask_qty = -order_depth.sell_orders[best_ask]
            if best_ask < theoretical_price:
                # Attempt to buy up to best_ask_qty or up to position limit
                buy_qty = min(best_ask_qty, position_limit - position)
                if buy_qty > 0:
                    orders.append(Order(product, round(best_ask), buy_qty))

        if order_depth.buy_orders:
            best_bid = max(order_depth.buy_orders.keys())
            best_bid_qty = order_depth.buy_orders[best_bid]
            if best_bid > theoretical_price:
                # Attempt to sell up to best_bid_qty or up to position limit
                sell_qty = min(best_bid_qty, position_limit + position)
                if sell_qty > 0:
                    orders.append(Order(product, round(best_bid), -sell_qty))

        return orders

    # 5) BREAD/JAM/DJEMBE/BASKET STRATEGIES
    def croissant_fair_value(self, order_depth: OrderDepth) -> float:
        if not order_depth.sell_orders or not order_depth.buy_orders:
            return 4300
        best_ask = min(order_depth.sell_orders.keys())
        best_bid = max(order_depth.buy_orders.keys())
        return (best_ask + best_bid) / 2

    def jam_fair_value(self, order_depth: OrderDepth) -> float:
        if not order_depth.sell_orders or not order_depth.buy_orders:
            return 6600
        best_ask = min(order_depth.sell_orders.keys())
        best_bid = max(order_depth.buy_orders.keys())
        return (best_ask + best_bid) / 2

    def djembe_fair_value(self, order_depth: OrderDepth) -> float:
        if not order_depth.sell_orders or not order_depth.buy_orders:
            return 13400
        best_ask = min(order_depth.sell_orders.keys())
        best_bid = max(order_depth.buy_orders.keys())
        return (best_ask + best_bid) / 2

    def croissant_orders(self, order_depth: OrderDepth, position: int, position_limit: int) -> List[Order]:
        orders: List[Order] = []
        fair_value = self.croissant_fair_value(order_depth)
        if order_depth.sell_orders:
            best_ask = min(order_depth.sell_orders.keys())
            available = -order_depth.sell_orders[best_ask]
            if best_ask < fair_value:
                quantity = min(available, position_limit - position, self.max_trade_volume)
                if quantity > 0:
                    orders.append(Order("CROISSANT", round(best_ask), quantity))
        if order_depth.buy_orders:
            best_bid = max(order_depth.buy_orders.keys())
            available = order_depth.buy_orders[best_bid]
            if best_bid > fair_value:
                quantity = min(available, position_limit + position, self.max_trade_volume)
                if quantity > 0:
                    orders.append(Order("CROISSANT", round(best_bid), -quantity))
        return orders

    def jam_orders(self, order_depth: OrderDepth,
                   position: int, position_limit: int) -> List[Order]:
        orders: List[Order] = []
        fair_value = self.jam_fair_value(order_depth)
        if order_depth.sell_orders:
            best_ask = min(order_depth.sell_orders.keys())
            available = -order_depth.sell_orders[best_ask]
            if best_ask < fair_value:
                quantity = min(available, position_limit - position, self.max_trade_volume)
                if quantity > 0:
                    orders.append(Order("JAM", round(best_ask), quantity))
        if order_depth.buy_orders:
            best_bid = max(order_depth.buy_orders.keys())
            available = order_depth.buy_orders[best_bid]
            if best_bid > fair_value:
                quantity = min(available, position_limit + position, self.max_trade_volume)
                if quantity > 0:
                    orders.append(Order("JAM", round(best_bid), -quantity))
        return orders

    def djembe_orders(self, order_depth: OrderDepth,
                      position: int, position_limit: int) -> List[Order]:
        orders: List[Order] = []
        fair_value = self.djembe_fair_value(order_depth)
        if order_depth.sell_orders:
            best_ask = min(order_depth.sell_orders.keys())
            available = -order_depth.sell_orders[best_ask]
            if best_ask < fair_value:
                quantity = min(available, position_limit - position, self.max_trade_volume)
                if quantity > 0:
                    orders.append(Order("DJEMBE", round(best_ask), quantity))
        if order_depth.buy_orders:
            best_bid = max(order_depth.buy_orders.keys())
            available = order_depth.buy_orders[best_bid]
            if best_bid > fair_value:
                quantity = min(available, position_limit + position, self.max_trade_volume)
                if quantity > 0:
                    orders.append(Order("DJEMBE", round(best_bid), -quantity))
        return orders

    def basket1_orders(self, order_depths: dict, position: int, position_limit: int) -> List[Order]:
        """
        For PICNIC_BASKET1, which is composed of:
          6 CROISSANTS, 3 JAM, 1 DJEMBE.
        We compute synthetic fair value from components.
        """
        croissant_depth = order_depths["CROISSANT"]
        jam_depth = order_depths["JAM"]
        djembe_depth = order_depths["DJEMBE"]
        basket_depth = order_depths["PICNIC_BASKET1"]

        synthetic_fv = (6 * self.croissant_fair_value(croissant_depth) +
                        3 * self.jam_fair_value(jam_depth) +
                        1 * self.djembe_fair_value(djembe_depth))
        orders = []
        if basket_depth.sell_orders:
            best_ask = min(basket_depth.sell_orders.keys())
            available = -basket_depth.sell_orders[best_ask]
            if best_ask < synthetic_fv:
                quantity = min(available, position_limit - position, self.max_trade_volume)
                if quantity > 0:
                    orders.append(Order("PICNIC_BASKET1", round(best_ask), quantity))
        if basket_depth.buy_orders:
            best_bid = max(basket_depth.buy_orders.keys())
            available = basket_depth.buy_orders[best_bid]
            if best_bid > synthetic_fv:
                quantity = min(available, position_limit + position, self.max_trade_volume)
                if quantity > 0:
                    orders.append(Order("PICNIC_BASKET1", round(best_bid), -quantity))
        return orders

    def basket2_orders(self, order_depths: dict, position: int, position_limit: int) -> List[Order]:
        """
        For PICNIC_BASKET2, composed of:
          4 CROISSANTS, 2 JAM.
        """
        croissant_depth = order_depths["CROISSANT"]
        jam_depth = order_depths["JAM"]
        basket_depth = order_depths["PICNIC_BASKET2"]

        synthetic_fv = 4 * self.croissant_fair_value(croissant_depth) + 2 * self.jam_fair_value(jam_depth)
        orders = []
        if basket_depth.sell_orders:
            best_ask = min(basket_depth.sell_orders.keys())
            available = -basket_depth.sell_orders[best_ask]
            if best_ask < synthetic_fv:
                quantity = min(available, position_limit - position, self.max_trade_volume)
                if quantity > 0:
                    orders.append(Order("PICNIC_BASKET2", round(best_ask), quantity))
        if basket_depth.buy_orders:
            best_bid = max(basket_depth.buy_orders.keys())
            available = basket_depth.buy_orders[best_bid]
            if best_bid > synthetic_fv:
                quantity = min(available, position_limit + position, self.max_trade_volume)
                if quantity > 0:
                    orders.append(Order("PICNIC_BASKET2", round(best_bid), -quantity))
        return orders

    # HELPER: CLEAR POSITION (Shared)
    def clear_position_order(self, orders: List[Order], order_depth: OrderDepth,
                             position: int, position_limit: int, product: str,
                             buy_order_volume: int, sell_order_volume: int,
                             fair_value: float, width: int) -> (int, int):
        position_after = position + buy_order_volume - sell_order_volume
        fair_bid = math.floor(fair_value)
        fair_ask = math.ceil(fair_value)
        buy_capacity  = position_limit - (position + buy_order_volume)
        sell_capacity = position_limit + (position - sell_order_volume)
        if position_after > 0:
            if fair_ask in order_depth.buy_orders:
                clear_qty = min(order_depth.buy_orders[fair_ask], position_after)
                qty_to_sell = min(sell_capacity, clear_qty)
                if qty_to_sell > 0:
                    orders.append(Order(product, round(fair_ask), -abs(qty_to_sell)))
                    sell_order_volume += abs(qty_to_sell)
        elif position_after < 0:
            if fair_bid in order_depth.sell_orders:
                clear_qty = min(abs(order_depth.sell_orders[fair_bid]), abs(position_after))
                qty_to_buy = min(buy_capacity, clear_qty)
                if qty_to_buy > 0:
                    orders.append(Order(product, round(fair_bid), qty_to_buy))
                    buy_order_volume += abs(qty_to_buy)
        return buy_order_volume, sell_order_volume

    # 6) MACARONS STRATEGY
    def macarons_implied_bid_ask(self, obs: ConversionObservation) -> (float, float):
        implied_bid = (
            obs.bidPrice
            - obs.exportTariff
            - obs.transportFees
            - 0.1        # storage cost baked in
        )
        implied_ask = (
            obs.askPrice
            + obs.importTariff
            + obs.transportFees
        )
        return implied_bid, implied_ask


    def macarons_arb_take(
        self,
        order_depth: OrderDepth,
        obs: ConversionObservation,
        position: int,
    ) -> (List[Order], int, int):
        orders, buy_vol, sell_vol = [], 0, 0
        ibid, iask = self.macarons_implied_bid_ask(obs)

        # how far we’re willing to cross
        aggressive_ask = round(obs.askPrice) - MACARONS_EDGE
        edge = max(0.0, (aggressive_ask - iask) * MACARONS_PROB)

        # BUY if sell‐orders under “ibid – edge”
        for price, vol in sorted(order_depth.sell_orders.items()):
            if price >= ibid - edge:
                break
            qty = min(abs(vol), MACARONS_LIMIT - position - buy_vol)
            if qty > 0:
                orders.append(Order(MACARONS, int(round(price)), qty))
                buy_vol += qty

        # SELL if buy‐orders above “iask + edge”
        for price, vol in sorted(order_depth.buy_orders.items(), reverse=True):
            if price <= iask + edge:
                break
            qty = min(vol, MACARONS_LIMIT + position - sell_vol)
            if qty > 0:
                orders.append(Order(MACARONS, int(round(price)), -qty))
                sell_vol += qty

        return orders, buy_vol, sell_vol


    def macarons_arb_make(
        self,
        obs: ConversionObservation,
        position: int,
        buy_vol: int,
        sell_vol: int,
    ) -> (List[Order], int, int):
        orders = []
        ibid, iask = self.macarons_implied_bid_ask(obs)

        # more aggressive than implied, but don’t chase too far
        aggr_bid = round(obs.bidPrice) + MACARONS_EDGE
        aggr_ask = round(obs.askPrice) - MACARONS_EDGE
        bid_px = aggr_bid if aggr_bid < ibid else ibid - 1
        ask_px = aggr_ask if aggr_ask > iask else iask + 1

        # post buys up to limit
        buy_qty = MACARONS_LIMIT - (position + buy_vol)
        if buy_qty > 0:
            orders.append(Order(MACARONS, int(round(bid_px)), buy_qty))

        # post sells up to limit
        sell_qty = MACARONS_LIMIT + (position - sell_vol)
        if sell_qty > 0:
            orders.append(Order(MACARONS, int(round(ask_px)), -sell_qty))

        return orders, buy_vol, sell_vol


    def macarons_arb_clear(self, position: int) -> int:
        if position > 0:
            return -min(position, MACARONS_CONV_LIMIT)
        if position < 0:
            return -max(position, -MACARONS_CONV_LIMIT)
        return 0

    # 7) MAIN RUN (ENTRY POINT)
    def run(self, state: TradingState):
        try:
            result = {}

            resin_position_limit = 50
            kelp_position_limit = 50
            squidink_position_limit = 50

            kelp_make_width = 3.5
            kelp_take_width = 1
            timespan = 10  # historical steps for KELP

            # RAINFOREST_RESIN orders:
            if "RAINFOREST_RESIN" in state.order_depths:
                resin_position = state.position.get("RAINFOREST_RESIN", 0)
                resin_orders = self.resin_orders(
                    state.order_depths["RAINFOREST_RESIN"],
                    fair_value=10000,  # fixed value
                    width=2,
                    position=resin_position,
                    position_limit=resin_position_limit
                )
                result["RAINFOREST_RESIN"] = resin_orders

            # KELP orders:
            if "KELP" in state.order_depths:
                kelp_position = state.position.get("KELP", 0)
                kelp_orders = self.kelp_orders(
                    state.order_depths["KELP"],
                    timespan,
                    kelp_make_width,
                    kelp_take_width,
                    kelp_position,
                    kelp_position_limit
                )
                result["KELP"] = kelp_orders

            # SQUID_INK orders:
            if "SQUID_INK" in state.order_depths:
                squidink_position = state.position.get("SQUID_INK", 0)
                squidink_orders = self.squidink_utility_orders(
                    state.order_depths["SQUID_INK"],
                    position=squidink_position,
                    position_limit=squidink_position_limit,
                    fair_value_base=2000,
                    candidate_range=2
                )
                result["SQUID_INK"] = squidink_orders

            pos_limits = {
                "CROISSANT": 250,
                "JAM": 350,
                "DJEMBE": 60,
                "PICNIC_BASKET1": 60,
                "PICNIC_BASKET2": 100,
            }
            if "CROISSANT" in state.order_depths:
                pos = state.position.get("CROISSANT", 0)
                result["CROISSANT"] = self.croissant_orders(state.order_depths["CROISSANT"], pos, pos_limits["CROISSANT"])
            if "JAM" in state.order_depths:
                pos = state.position.get("JAM", 0)
                result["JAM"] = self.jam_orders(state.order_depths["JAM"], pos, pos_limits["JAM"])
            if "DJEMBE" in state.order_depths:
                pos = state.position.get("DJEMBE", 0)
                result["DJEMBE"] = self.djembe_orders(state.order_depths["DJEMBE"], pos, pos_limits["DJEMBE"])
            if all(p in state.order_depths for p in ["CROISSANT", "DJEMBE", "JAM", "PICNIC_BASKET1"]):
                basket_position = state.position.get("PICNIC_BASKET1", 0)
                result["PICNIC_BASKET1"] = self.basket1_orders(
                    state.order_depths,
                    basket_position,
                    pos_limits["PICNIC_BASKET1"]
                )
            if all(p in state.order_depths for p in ["CROISSANT", "DJEMBE", "JAM", "PICNIC_BASKET2"]):
                basket_position = state.position.get("PICNIC_BASKET2", 0)
                result["PICNIC_BASKET2"] = self.basket2_orders(
                    state.order_depths,
                    basket_position,
                    pos_limits["PICNIC_BASKET2"]
                )

            for voucher_product in self.volcanic_voucher_config.keys():
                if voucher_product in state.order_depths:
                    pos = state.position.get(voucher_product, 0)
                    voucher_od = state.order_depths[voucher_product]
                    voucher_orders = self.volcanic_voucher_orders(voucher_product, voucher_od, pos)
                    if voucher_orders:
                        result[voucher_product] = voucher_orders

            prices = {}
            for prod, fallback in [("CROISSANT", 4300), ("JAM", 6600), ("DJEMBE", 13400)]:
                if prod in state.order_depths:
                    prices[prod] = self.mid_price(state.order_depths[prod], fallback)
                else:
                    prices[prod] = fallback
            if "PICNIC_BASKET1" in state.order_depths:
                prices["PICNIC_BASKET1"] = self.mid_price(
                    state.order_depths["PICNIC_BASKET1"],
                    6 * prices["CROISSANT"] + 3 * prices["JAM"] + prices["DJEMBE"]
                )
            else:
                prices["PICNIC_BASKET1"] = 6 * prices["CROISSANT"] + 3 * prices["JAM"] + prices["DJEMBE"]
            if "PICNIC_BASKET2" in state.order_depths:
                prices["PICNIC_BASKET2"] = self.mid_price(
                    state.order_depths["PICNIC_BASKET2"],
                    4 * prices["CROISSANT"] + 2 * prices["JAM"]
                )
            else:
                prices["PICNIC_BASKET2"] = 4 * prices["CROISSANT"] + 2 * prices["JAM"]

            lp_decision, lp_profit = self.optimize_conversion_arbitrage(prices, pos_limits)
            conversion_orders = self.decompose_lp_conversion_orders(state, prices, lp_decision)
            for order in conversion_orders:
                symbol = order.symbol
                if symbol in result:
                    result[symbol].append(order)
                else:
                    result[symbol] = [order]

            if MACARONS in state.order_depths and MACARONS in state.observations.conversionObservations:
                pos = state.position.get(MACARONS, 0)

                # 1) clear out existing inventory via conversion
                conv_qty = self.macarons_arb_clear(pos)
                pos_after = pos + conv_qty

                # 2) “take” crossed quotes
                take_orders, bv, sv = self.macarons_arb_take(
                    state.order_depths[MACARONS],
                    state.observations.conversionObservations[MACARONS],
                    pos_after
                )

                # 3) “make” passive quotes
                make_orders, _, _ = self.macarons_arb_make(
                    state.observations.conversionObservations[MACARONS],
                    pos_after, bv, sv
                )

                # 4) publish orders & conversions
                result[MACARONS] = take_orders + make_orders
                conversions = conv_qty

            # Build traderData (e.g., time series data)
            traderData = jsonpickle.encode({
                "kelp_prices": self.kelp_prices,
                "kelp_vwap": self.kelp_vwap,
                "squidink_prices": self.squidink_prices,
                "flipper_second_bids": self.flipper_second_bids,
            })

            conversions = 1

            return result, conversions, traderData

        except Exception as e:
            raise Exception(e)
            print("Exception in trader.run:", e)
            return {}, 0, ""